[
  {
    "tag": "technical javascript module commonjs esm",
    "title": "Writing a JavaScript Module That Works in Both CommonJS and ESM",
    "cover": "/posts/my-dual-npm-module.webp",
    "summary": "A guide on how to write a module that works in both CoommonJS and ESM",
    "publishedAt": "2025-02-25T00:00:00.000Z",
    "body": {
      "raw": "\n## Introduction\nJavaScript module systems have evolved significantly over the years. While CommonJS (CJS) has been the standard for Node.js, ECMAScript Modules (ESM) have gained traction due to their modern syntax and support in both browsers and Node.js. However, maintaining compatibility between both module systems can be a challenge for developers publishing NPM packages.\n\nIn this article, I will walk you through my journey of building a JavaScript module that seamlessly supports both CommonJS and ESM. You can find the complete project and tutorial in my GitHub repository: [my-dual-npm-module](https://github.com/radmanesh/my-dual-npm-module).\n\n## Why Support Both CommonJS and ESM?\n\nMany projects and libraries still rely on CommonJS, while modern tooling and frameworks prefer ESM. Supporting both ensures your module remains versatile and accessible to a broader range of users.\n\nSome key reasons to support both:\n\n* **Backward Compatibility:** Many Node.js projects still use CommonJS.\n\n* **Future-Proofing:** ESM is the standard moving forward.\n\n* **Interoperability:** Some build tools expect one format over another.\n\n* **Better Tree Shaking:** ESM enables more efficient tree shaking for smaller bundle sizes.\n\n---\n\n## The Challenges of Dual Support\n\nWhile Node.js now supports ESM natively, CommonJS and ESM have fundamental differences:\n\n* **Import/Export Syntax:** require() vs. import.\n\n* File Extensions: .cjs for CommonJS and .mjs for ESM.\n\n* Package.json Configuration: type field determines module system behavior.\n\n* Default Exports Handling: CommonJS uses module.exports, whereas ESM uses export default.\n\nThese differences mean you need a strategy to ensure smooth interoperability.\n\n---\n\n\n##Steps to Build a Dual-Compatible Module\n\n###1. Project Setup\nCreate your project and initialize an NPM package:\n\n```\nmkdir my-dual-module && cd my-dual-module\nnpm init -y\n```\n\nModify package.json to support both module systems:\n\n```\n{\n  \"name\": \"my-dual-module\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.mjs\",\n  \"exports\": {\n    \"import\": \"./dist/index.mjs\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\"\n  }\n}\n```\n\n###2. Writing the Module Code\n\nCreate a src/index.ts file with the following content:\n\n```javascript\nexport function greet(name: string) {\n  return `Hello, ${name}!`;\n}\n```\n\nFor CommonJS compatibility, create a wrapper:\n\n```javascript\n// src/index.cjs.ts\nconst { greet } = await import(\"./index.mjs\");\nmodule.exports = { greet };\n```\n\n###3. Compiling for Both Formats\n\nUse TypeScript to compile the code for both CommonJS and ESM. Create a tsconfig.json file:\n\n```javascript\n{\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"module\": \"ESNext\",\n    \"target\": \"ES6\",\n    \"moduleResolution\": \"node\",\n    \"declaration\": true,\n    \"esModuleInterop\": true\n  },\n  \"include\": [\"src\"]\n}\n```\nRun the build command:\n\n```\nnpm run build\n```\n\n###4. Using the Module\n\nFor CommonJS:\n```javascript\nconst { greet } = require(\"my-dual-module\");\nconsole.log(greet(\"World\"));\n```\nFor ESM:\n\n```javascript\nimport { greet } from \"my-dual-module\";\nconsole.log(greet(\"World\"));\n```\n\n##Conclusion\n\nBuilding a JavaScript module that works in both CommonJS and ESM ensures compatibility and longevity. While it requires additional configuration, the benefits outweigh the effort, making your package usable across different environments.\n\nIf you're interested in seeing the full implementation, check out my repository: my-dual-npm-module. I’d love to hear your thoughts and experiences with dual-module development!\n\nLet’s keep the discussion going in the comments!\n\n## More Resources\n\n- [Node.js Documentation on Modules](https://nodejs.org/api/packages.html#dual-commonjses-module-packages)\n- [Package.json Exports Field](https://nodejs.org/api/packages.html#exports)\n",
      "code": "var Component=(()=>{var m=Object.create;var t=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var f=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),S=(o,e)=>{for(var r in e)t(o,r,{get:e[r],enumerable:!0})},d=(o,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!y.call(o,i)&&i!==r&&t(o,i,{get:()=>e[i],enumerable:!(l=p(e,i))||l.enumerable});return o};var b=(o,e,r)=>(r=o!=null?m(g(o)):{},d(e||!o||!o.__esModule?t(r,\"default\",{value:o,enumerable:!0}):r,o)),j=o=>d(t({},\"__esModule\",{value:!0}),o);var s=f((C,a)=>{a.exports=_jsx_runtime});var v={};S(v,{default:()=>h,frontmatter:()=>M});var n=b(s()),M={title:\"Writing a JavaScript Module That Works in Both CommonJS and ESM\",publishedAt:\"2025-02-25\",summary:\"A guide on how to write a module that works in both CoommonJS and ESM\",cover:\"/posts/my-dual-npm-module.webp\",tag:\"technical javascript module commonjs esm\"};function c(o){let e={a:\"a\",code:\"code\",h2:\"h2\",hr:\"hr\",li:\"li\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...o.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Introduction\"}),`\n`,(0,n.jsx)(e.p,{children:\"JavaScript module systems have evolved significantly over the years. While CommonJS (CJS) has been the standard for Node.js, ECMAScript Modules (ESM) have gained traction due to their modern syntax and support in both browsers and Node.js. However, maintaining compatibility between both module systems can be a challenge for developers publishing NPM packages.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this article, I will walk you through my journey of building a JavaScript module that seamlessly supports both CommonJS and ESM. You can find the complete project and tutorial in my GitHub repository: \",(0,n.jsx)(e.a,{href:\"https://github.com/radmanesh/my-dual-npm-module\",children:\"my-dual-npm-module\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Why Support Both CommonJS and ESM?\"}),`\n`,(0,n.jsx)(e.p,{children:\"Many projects and libraries still rely on CommonJS, while modern tooling and frameworks prefer ESM. Supporting both ensures your module remains versatile and accessible to a broader range of users.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Some key reasons to support both:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Backward Compatibility:\"}),\" Many Node.js projects still use CommonJS.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Future-Proofing:\"}),\" ESM is the standard moving forward.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Interoperability:\"}),\" Some build tools expect one format over another.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Better Tree Shaking:\"}),\" ESM enables more efficient tree shaking for smaller bundle sizes.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"The Challenges of Dual Support\"}),`\n`,(0,n.jsx)(e.p,{children:\"While Node.js now supports ESM natively, CommonJS and ESM have fundamental differences:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Import/Export Syntax:\"}),\" require() vs. import.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"File Extensions: .cjs for CommonJS and .mjs for ESM.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Package.json Configuration: type field determines module system behavior.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Default Exports Handling: CommonJS uses module.exports, whereas ESM uses export default.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"These differences mean you need a strategy to ensure smooth interoperability.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.p,{children:\"##Steps to Build a Dual-Compatible Module\"}),`\n`,(0,n.jsx)(e.p,{children:`###1. Project Setup\nCreate your project and initialize an NPM package:`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`mkdir my-dual-module && cd my-dual-module\nnpm init -y\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Modify package.json to support both module systems:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`{\n  \"name\": \"my-dual-module\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.mjs\",\n  \"exports\": {\n    \"import\": \"./dist/index.mjs\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\"\n  }\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"###2. Writing the Module Code\"}),`\n`,(0,n.jsx)(e.p,{children:\"Create a src/index.ts file with the following content:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:\"export function greet(name: string) {\\n  return `Hello, ${name}!`;\\n}\\n\"})}),`\n`,(0,n.jsx)(e.p,{children:\"For CommonJS compatibility, create a wrapper:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`// src/index.cjs.ts\nconst { greet } = await import(\"./index.mjs\");\nmodule.exports = { greet };\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"###3. Compiling for Both Formats\"}),`\n`,(0,n.jsx)(e.p,{children:\"Use TypeScript to compile the code for both CommonJS and ESM. Create a tsconfig.json file:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`{\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"module\": \"ESNext\",\n    \"target\": \"ES6\",\n    \"moduleResolution\": \"node\",\n    \"declaration\": true,\n    \"esModuleInterop\": true\n  },\n  \"include\": [\"src\"]\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Run the build command:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`npm run build\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"###4. Using the Module\"}),`\n`,(0,n.jsx)(e.p,{children:\"For CommonJS:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`const { greet } = require(\"my-dual-module\");\nconsole.log(greet(\"World\"));\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"For ESM:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`import { greet } from \"my-dual-module\";\nconsole.log(greet(\"World\"));\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"##Conclusion\"}),`\n`,(0,n.jsx)(e.p,{children:\"Building a JavaScript module that works in both CommonJS and ESM ensures compatibility and longevity. While it requires additional configuration, the benefits outweigh the effort, making your package usable across different environments.\"}),`\n`,(0,n.jsx)(e.p,{children:\"If you're interested in seeing the full implementation, check out my repository: my-dual-npm-module. I\\u2019d love to hear your thoughts and experiences with dual-module development!\"}),`\n`,(0,n.jsx)(e.p,{children:\"Let\\u2019s keep the discussion going in the comments!\"}),`\n`,(0,n.jsx)(e.h2,{children:\"More Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://nodejs.org/api/packages.html#dual-commonjses-module-packages\",children:\"Node.js Documentation on Modules\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://nodejs.org/api/packages.html#exports\",children:\"Package.json Exports Field\"})}),`\n`]})]})}function h(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,{...o,children:(0,n.jsx)(c,{...o})}):c(o)}return j(v);})();\n;return Component;"
    },
    "_id": "my-dual-npm-module.mdx",
    "_raw": {
      "sourceFilePath": "my-dual-npm-module.mdx",
      "sourceFileName": "my-dual-npm-module.mdx",
      "sourceFileDir": ".",
      "contentType": "mdx",
      "flattenedPath": "my-dual-npm-module"
    },
    "type": "Post",
    "url": "/blog/my-dual-npm-module",
    "readingTime": 3
  }
]